General
  Comment : 주석, single(// ...), multi(/* ... */), JavaDoc(/** ... */)
  OOP : Abstraction, Inheritance, Polymorphism, Encapsulation
  Console IO
  	output : System.out.println(내용)
  	input
  		Scanner scan = new Scanner(System.in);
  		데이터형 변수 = scan.next메소드;
  		next() nextInt() ...

Datatype/데이터형
  character & string
    '문' : 문자
    "문자열" : 문자열
    결합 : "문자"+"열입니다"
    escape : \, "blitz said \"This is Java\"" == blitz said "This is Java"
    줄바꿈 : \n
  datatype 
    정수 : int 기본
      byte(1), short(2 byte), int(4 byte), long(8 byte)
    실수 : double 기본
      float(4 byte), double(8 byte)
    문자
      char(2 byte), String(2 byte 배수)
    variable(변수)
	  int a; double b
	constant(상수)
	  int a = 200; double b = 12345;
	  long c = 12345L; float d = 12345F;
  conversion : 형변환
  	implicit(자동/암시적) : 데이터 손실이 없을 경우 실행.
  	  byte -> short/char -> int -> long -> float ->double
  	explicit(명시적) : cast
  	  int a = (int) 100.0F;

Operator/연산자
  arithmetic : + - * / %
    + : 문자열 합하기에도 사용
    5%3 = 2
  unary : 단항, -10, ++i, i--
    a + b는 binary(이항)
  compare : equal(==), not equal(!=), greater(>), greaterequal(>=), <, <=
  logic : and(&&), or(||)
  tertiary : 삼항, ?
  	int i = h !=5 ? 1:2;	h=5면 i=2 아니면 i=1
  short
  	"i += 100" 는" i = i + 100"

Condtion/조건문
  IF문 : if (조건1) {코드1} else if (조건2) {코드2} ... else {코드}
  SWITCH 문: switch (변수) {case 변수:코드;break; ...}

Loop/반복문
  WHILE 문 : while (조건) {코드};
  FOR 문 : for (초기화; 조건; 실행) {코드}
  FOREACH 문 : for (배열원소:배열) {코드}, ENUM 참조

Array/배열
  정의
  	데이터형[] 변수명 = {a1, a2...};
  	데이터형[] 변수명 = new 데이터형[크기];
  한계 : 정의 할때 크기가 지정되며 사용시 범위를 넘으면 안됨.(collection)
  eg
  	String[] sentence = {"This","is","a","sentence"};
  	String phrase = Arrays.toString(sentence);
  eg2, 다차원 배열1
  	int[][] 2d = new int[2][2];
  	2d[0][0] = 10;
  	2d[0][1] = 20;
  	2d[1][0] = 100;
  	2d[1][1] = 200;
  eg2, 다차원 배열2
  	int[][] 2d = new int[3][];
  	2d[0] = new int[2];
  	2d[1] = new int[5];
  	2d[3] = new int[4];
  
Object/객체
	class : 객체의 설계도
	instance : 객체, 클래스타입 변수 = new 클래스명()
	constructor/생성자
	 객체의 생성자, 객체를 생성할때 제일 처음 실행, 초기화 작업 실행.
	 클래스명과 동일한 메소드로 직접 정의할수 있음.
	 직접 정의 안하면 자동으로 만들어짐, 직접 정의 하면 기본 생성자를 직접 정의 해야함.
	 상속 : sub class 생성시 super class의 기본 생성자 필수, super()
	void : return이 없음
	Scope/유효범위
		static scope, lexical scope, 정적인 유효범위, 정의된 지역 변수 -> 전역 변수(Java)
		dynamic scope, 동적인 유효범, 사용 시점 지역 변수 -> 전역 변수 (근대적 언어)

Inheritance/상속
	기능
		자신의 클래스 맴버에 다른 클래스 맴버 전체를 추가. 
	 	자신은 자식(sub, derived) 클래스, 다른 클래스는 부모(super, base)가 된다
	문법
		class 자식클래스 extends 부모클래스 {}
		public class ChildClass extents ParentClass {}
	특징
 		overriding 및 overload 기능을 통해 자식을 부모와 다르게 할수 있음
 		자식을 생성자를 통해 생성하면 자동으로 부모도 생성, 즉 부모 생성자 실행
	overriding
		자식을 부모와 다르게 하는 방법.
		부모 클래스의 메소드를 외모가 같고 기능이 다른 자식 메소드로 교체. (property?)
		자식 메소드의 서명/signature이 부모와 동일 (메소드 이름, 매개변수 내용, 리턴 타입). super.메소드명
		@Override : overriding 할 subclass 메소드를 명확하게 정의
	overloading 
		자식을 부모와 다르게 하는 방법.
		부모 메소드와 비슷하지만 기능이 다른 자식 메소들이 부모 메소드와 같이 공존
		자식 메소드 이름은 부모와 동일하고 매개변수 내용이 달라야함. 
	this/super
		this : 자신 객체, this.변수, this.메소드()
		super : 부모 객체, super.변수, super.메소드()

Package
	구조 : root(project src & bin)/package/파일(*.java & *.class)
	사용 : 패키지 로드, 동일한 이름의 클래스들의 로드 조심.
		import kr.co.iamtek.java

Modifier(제어자)
	Static
		기능 : class property/method, instance와 별개로 존재
		특징
			Class member vs instance member 관계
				instance method -> class members
				class method -x-> instance members
  			Memory 관리
			  	Data : classes & class members, 개발자가 직접 챙겨야 함
  				Heap : objects/instances, garbage collector가 관리
	Access(접근)
		기능 : 사용/접근 여부를 정하는 제어자.
			public일 경우 파일명 = 클래스명, 즉 소스코드 하나당 public class가 한개만 존재 가능.
		대상 : class, class member
			Class member : public > protected > default > private
			Class : public > default
		종류 : 일반적으로 public 사용, 보안이 중요하면 private 사용.
			public : 모두 사용/접근 가능.
			protected : 같은 package, 다른 package 상속관계 사용/접근 가능. 
			default : 같은 package만 사용/접근 가능.
			private : 같은 class만 사용/접근 가능.
	Abstract(추상화)
		기능 : 상속을 강제 하는 제어자.
		 	부모 클래스는 형식만 정하고 상세 동작 방법은 자식 클래스에게 위임.
		 	일반 메소드 존재 가능.
		대상 : class, method
		 	class : 추상 클래스는 직접 사용 못하고 상속을 통해서만 사용 가능.
		 	method : 부모의 추상 메소드는 자식이 override 해서 사용.
	Final
		기능 : 상속을 금지 하는 제어자, abstract의 반대.
		대상 : class, class members
			class : final class는 자식 클래스를 생성 못함, 즉 상속이 불가능.
			method : final method는 자식 클래스에서 override이 불가능, overload는 가능.
			field : final field는 값이 정해지면 변경이 불가능.
	Interface
		기능
			객체의 작업 명세서/지시서, " 앞으로 이렇게 만들어요" 약속
			여러 객체를 하나로 묶는 기능 제공, 반복문에 적용
			Datatype이 목적, 객체 생성이 목적이 아닌 데이터타입을 정의/사용하는 것이 목적
		문법
			Interface
				public InterfaceEx {
					public static final in CONSTANT = 10;
					public void someMethod();
				}
			Class : 클래스는 인터페이스를 구현
				class SomeClass implements InterfaceEx {}
		특징
			상수와 추상메소드로 구성, field(public static final), method(public abstract)
			데이터 타입으로만 사용 가능, 객체로 사용 못함
			다중구현(Multi implementation)
				Java는 다중 상속이 불가능하지만 복수의 인터페이스를 구현 가능
				Polymorphism 의 핵심
					상속 : ParentClass class = new ChildClass();
					인터페이스 : Interface class = new Class();
						복수 Interface들을 구현한 Class
			Anonymous
				클래스로 구현하지 않고 바로 객체로 사용시 생성할때 구현을 한다. 추상 클래스도 동일. 

Polymorphism(다향성)
	Concept : 무언가가 상황에 따라 다르게 동작/행동 하는것.
	method : method overload
	class : ParentClass 클래스 = new ChildClass()
		자식클래스 인스턴스가 부모 클래스 행세를 하는것, 데이터형이 부모인 자식 인스턴스.
		override method(부모에게 물려받은, 부모에게 존재)만 사용 가능, 자식 method가 사용.
		interface도 동일.

Exception(예외)
	Exception class instance, e
		e.getMessage() e.toString() e.printStackTrace()
	Try-catch : Exception을 받아서 처리.
		syntax : try{logic1} catch(Exception e) {logic2} catch() {}...finally {logic3}
		logic1 : 오류 가능성이 있는 코드.
		logic2 : 코드1 오류 발생시 실행 되는 코드.
		logic3 : 오류와 관계없이 실행 되는 코드.
	Throws : Exception을 호출자/사용자에게 넘기기.
		syntax : method() throws eClass1, eClass2 {}
	Manual handling : 직접 예외 처리 만들기
		syntax : throw new eClass()
	Checked vs unchecked
		Checked : 강제 예외 처리, 예외도 예외 처리, RuntimeException이 상위 클래스에 없음.
		Unchecked : 예외 처리 자유, RuntimeException이 상위 클래스에 존재.
		
Progenitor Object class
	설명 : 모든 클래스의 시조 클래스
		class Obj {} == class Obj extends Object {}
	메소드 : 모든 클래스는 Object 클래스의 메소드를 물려 받아 사용 가능하며 override를 통해 기능 변경 가능.
		toString() : 객체->문자열, 수정 권장
		equals() : 동일한지 비교, 객체의 경우 그대로 원시 데이터형은 수정(조심)하거나 == 비교 연산자 사용
		finalize() :
		clone() : 객체 복제, Cloneable interface 구현 필요, 복제된 객체의 데이터형 조심.
		
ENUM/Enumerated type (열거형)
	설명 : 연관된 상수들의 집합, 연관된 변수들의 집합인 배열과 비슷, foreach로 처리 가능.
	특징 : 클래스와 비슷하되 인스턴스 생성(private constructor) 및 상속 불가.
	FOREACH 문 :
		enum example {};
		for (example no : example.values()) {코드};
	Method
		hasMoreElements() .nextElement()

Reference (참조)
	Primitive/원시형 : 8개. byte short int long, float double, boolean, char.
	Reference/참조형 : 원시형을 제외한 데이터형, 객체, 선언할때 new 즉 생성자를 사용.
	
Generic
	설명 : 클래스 내부에서 사용될 데이터형을 외부에서 지정. 함수의 매개변수와 비슷한 계념.
	문법
		Class : Class <Generic>
		Method : <Generic> Method
	제한
		참조 데이터형만 사용 가능, 원시 데이터형은 wrapper class를 통해 사용 가능.
		ClassA <Generic extends ClassB> : ClassB의 자식만 Generic으로 사용 가능.

Collections framework
	설명 : data container, 데이터를 담고 다루는 기능을 가진 컨테이너, 가능하면 상위 컨테이너 사용 권장.
	Collection : List Set을 포함하는 상위 컨테이너, Iterator 기능 포함.
	List : 배열, 순서 존재, 중복 가능.
		ArrayList<>() : 저장소 생성, generic.
		size() 크기, get(인덱스) 조회
	Set : 집합, 순서가 없음, 중복 불가.
		HashSet<>() : 저장소 생성, generic.
		containsAll() subset, addAll() union, retainAll() intersect, removeAll() difference.
	Map : 2개의 데이터가 쌍으로 저장, key는 중복 불가, value는 중복 가능
		HashMap<>() : 저장소 생성, 2 generic, 함수
		put(key, value) 추가, get(key) 조회 
		Loop : iterator가 없기 때문에 컨테이너를 collection으로 변경 필요.
			Set<Entry> 집합 = 맵.entrySet();
			for (Entry 집합원소 : 집합) or Iterator mi = 집합.iterator();while (mi.hasNext())			
	Iterator : Collections 저장소 내용 조회
		iterator() 생성, hasNext() 내용존재 확인, next() 조회 및 삭제.
	Sort : 컨테이너 내용 정렬.
		정렬할 컨테이너는 Comparable 인터페이스 구현 필요.
		Collections.sort(컨테이너)

Design pattern
	뭔지 잘 모르겠다
	Singleton pattern
		클래스의 인스턴스를 1개로 제한/보장하고 접근을 전역적 접촉점으로 제공.
	Strategic pattern
		부품화, 기존 예제는 객체들을 너무 많이 생성하는듯, singleton을 적용하면 좋을듯.